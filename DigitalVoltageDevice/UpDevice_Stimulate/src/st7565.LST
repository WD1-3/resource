C51 COMPILER V9.54   ST7565                                                                12/09/2024 17:21:32 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE ST7565
OBJECT MODULE PLACED IN st7565.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE st7565.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\程序) DEBUG OBJECTEXTEND TAB
                    -S(2)

line level    source

   1          #include"st7565.h"
   2          
   3          /*******************************************************************************
   4          * 函 数 名         : LCD12864_WriteCmd
   5          * 函数功能       : 写入一个命令到12864
   6          * 输    入         : cmd
   7          * 输    出         : 无
   8          *******************************************************************************/
   9          
  10          void LcdSt7565_WriteCmd(cmd)
  11          {
  12   1        LCD12864_CS = 0;     //chip select,打开片选
  13   1        LCD12864_RD = 1;     //disable read，读失能 
  14   1        LCD12864_RS = 0;       //select command，选择命令
  15   1        LCD12864_RW = 0;       //select write，选择写模式
  16   1        _nop_();
  17   1        _nop_();
  18   1      
  19   1        DATA_PORT = cmd; //put command，放置命令
  20   1        _nop_();
  21   1        _nop_();
  22   1      
  23   1        LCD12864_RW = 1;     //command writing ，写入命令
  24   1      }
  25          
  26          /*******************************************************************************
  27          * 函 数 名         : LcdSt7565_WriteData
  28          * 函数功能       : 写入一个数据到12864
  29          * 输    入         : dat
  30          * 输    出         : 无
  31          *******************************************************************************/
  32          
  33          void LcdSt7565_WriteData(dat)
  34          { 
  35   1        LCD12864_CS = 0;     //chip select，打开片选
  36   1        LCD12864_RD = 1;     //disable read，读失能 
  37   1        LCD12864_RS = 1;       //select data，选择数据
  38   1        LCD12864_RW = 0;       //select write，选择写模式
  39   1        _nop_();
  40   1        _nop_();
  41   1      
  42   1        DATA_PORT = dat;       //put data，放置数据
  43   1        _nop_();
  44   1        _nop_();
  45   1      
  46   1        LCD12864_RW = 1;     //data writing，写数据 
  47   1      }
  48          /*******************************************************************************
  49          * 函 数 名         : LCD12864_Init
  50          * 函数功能       : 初始化12864
  51          * 输    入         : 无
  52          * 输    出         : 无
  53          * 说    明         : LCD12864的命令指令可以查看例程文件夹下的《ST7565p数据手册》
  54          *                  * 的第51页的位置。
C51 COMPILER V9.54   ST7565                                                                12/09/2024 17:21:32 PAGE 2   

  55          *******************************************************************************/
  56          
  57          void Lcd12864_Init()
  58          {
  59   1        uchar i;
  60   1        LCD12864_RSET = 0;
  61   1        for (i=0; i<100; i++);
  62   1        LCD12864_CS = 0;
  63   1        LCD12864_RSET = 1;
  64   1        
  65   1        //----------------Star Initial Sequence-------//
  66   1        //------程序初始化设置，具体命令可以看文件夹下---//
  67   1      
  68   1        //--软件初始化--//
  69   1        LcdSt7565_WriteCmd(0xE2);  //reset
  70   1        for (i=0; i<100; i++);     //延时一下
  71   1      
  72   1        //--表格第8个命令，0xA0段（左右）方向选择正常方向（0xA1为反方向）--//
  73   1        LcdSt7565_WriteCmd(0xA0);  //ADC select segment direction 
  74   1        
  75   1        //--表格第15个命令，0xC8普通(上下)方向选择选择反向，0xC0为正常方向--// 
  76   1        LcdSt7565_WriteCmd(0xC0);  //Common direction 
  77   1                          
  78   1        //--表格第9个命令，0xA6为设置字体为黑色，背景为白色---//
  79   1        //--0xA7为设置字体为白色，背景为黑色---//
  80   1        LcdSt7565_WriteCmd(0xA6);  //reverse display
  81   1      
  82   1        //--表格第10个命令，0xA4像素正常显示，0xA5像素全开--//
  83   1        LcdSt7565_WriteCmd(0xA4);  //normal display
  84   1        
  85   1        //--表格第11个命令，0xA3偏压为1/7,0xA2偏压为1/9--//
  86   1        LcdSt7565_WriteCmd(0xA2);  //bias set 1/9
  87   1        
  88   1        //--表格第19个命令，这个是个双字节的命令，0xF800选择增压为4X;--//
  89   1        //--0xF801,选择增压为5X，其实效果差不多--// 
  90   1        LcdSt7565_WriteCmd(0xF8);  //Boost ratio set
  91   1        LcdSt7565_WriteCmd(0x01);  //x4
  92   1        
  93   1        //--表格第18个命令，这个是个双字节命令，高字节为0X81，低字节可以--//
  94   1        //--选择从0x00到0X3F。用来设置背景光对比度。---/
  95   1        LcdSt7565_WriteCmd(0x81);  //V0 a set
  96   1        LcdSt7565_WriteCmd(0x23);
  97   1      
  98   1        //--表格第17个命令，选择调节电阻率--//
  99   1        LcdSt7565_WriteCmd(0x25);  //Ra/Rb set
 100   1        
 101   1        //--表格第16个命令，电源设置。--//
 102   1        LcdSt7565_WriteCmd(0x2F);
 103   1        for (i=0; i<100; i++);
 104   1      
 105   1        //--表格第2个命令，设置显示开始位置--//
 106   1        LcdSt7565_WriteCmd(0x40);  //start line
 107   1      
 108   1        //--表格第1个命令，开启显示--//
 109   1        LcdSt7565_WriteCmd(0xAF);  // display on
 110   1        for (i=0; i<100; i++);
 111   1      
 112   1      }
 113          
 114          /*******************************************************************************
 115          * 函 数 名         : LCD12864_ClearScreen
 116          * 函数功能       : 清屏12864
C51 COMPILER V9.54   ST7565                                                                12/09/2024 17:21:32 PAGE 3   

 117          * 输    入         : 无
 118          * 输    出         : 无
 119          *******************************************************************************/
 120          
 121          void Lcd12864_ClearScreen(void)
 122          {
 123   1        uchar i, j;
 124   1      
 125   1        for(i=0; i<8; i++)
 126   1        {
 127   2          //--表格第3个命令，设置Y的坐标--//
 128   2          //--Y轴有64个，一个坐标8位，也就是有8个坐标--//
 129   2          //所以一般我们使用的也就是从0xB0到0x07,就够了--// 
 130   2          LcdSt7565_WriteCmd(0xB0+i); 
 131   2      
 132   2          //--表格第4个命令，设置X坐标--//
 133   2          //--当你的段初始化为0xA1时，X坐标从0x10,0x04到0x18,0x04,一共128位--//
 134   2          //--当你的段初始化为0xA0时，X坐标从0x10,0x00到0x18,0x00,一共128位--//
 135   2          //--在写入数据之后X坐标的坐标是会自动加1的，我们初始化使用0xA0所以--//
 136   2          //--我们的X坐标从0x10,0x00开始---//
 137   2          LcdSt7565_WriteCmd(0x10); 
 138   2          LcdSt7565_WriteCmd(0x04);                
 139   2          
 140   2          //--X轴有128位，就一共刷128次，X坐标会自动加1，所以我们不用再设置坐标--//
 141   2          for(j=0; j<128; j++)
 142   2          {
 143   3            LcdSt7565_WriteData(0x00);  //如果设置背景为白色时，清屏选择0XFF
 144   3          }
 145   2        }
 146   1      }
 147          
 148          /*******************************************************************************
 149          * 函 数 名         : LCD12864_Write16CnCHAR
 150          * 函数功能       : 在12864上面书写16X16的汉字
 151          * 输    入         : x, y, cn
 152          * 输    出         : 无
 153          * 说    明       : 该函数可以直接书写字符串，但是书写是从右到左，所以输入的时
 154          *                  * 侯注意输入。汉字的取模方式请观看文件夹下的《汉字取模软件的
 155          *                  * 使用说明》
 156          *******************************************************************************/
 157          
 158          #ifdef  CHAR_CODE
 159          
 160          #include"charcode.h"
 161          
 162          uchar Lcd12864_Write16CnCHAR(uchar x, uchar y, uchar *cn)
 163          {
 164   1        uchar j, x1, x2, wordNum;
 165   1      
 166   1        //--Y的坐标只能从0到7，大于则直接返回--//
 167   1        if(y > 7)
 168   1        {
 169   2          return 0;
 170   2        }
 171   1      
 172   1        //--X的坐标只能从0到128，大于则直接返回--//
 173   1        if(x > 128)
 174   1        {
 175   2          return 0;
 176   2        }
 177   1        y += 0xB0;     //求取Y坐标的值
 178   1        //--设置Y坐标--//
C51 COMPILER V9.54   ST7565                                                                12/09/2024 17:21:32 PAGE 4   

 179   1        LcdSt7565_WriteCmd(y);
 180   1        while ( *cn != '\0')   //在C语言中字符串结束以‘\0’结尾
 181   1        { 
 182   2        
 183   2          //--设置Y坐标--//
 184   2          LcdSt7565_WriteCmd(y);
 185   2      
 186   2          x1 = (x >> 4) & 0x0F;   //由于X坐标要两句命令，分高低4位，所以这里先取出高4位
 187   2          x2 = x & 0x0F;          //去低四位
 188   2          //--设置X坐标--//
 189   2          LcdSt7565_WriteCmd(0x10 + x1);   //高4位
 190   2          LcdSt7565_WriteCmd(0x04 + x2);  //低4位
 191   2      
 192   2          for (wordNum=0; wordNum<(sizeof(CN16CHAR)/sizeof(struct Cn16CharTypeDef)); wordNum++)
 193   2          {
 194   3              //--查询要写的字在字库中的位置--//
 195   3            if ((CN16CHAR[wordNum].Index[0] == *cn)
 196   3                 &&(CN16CHAR[wordNum].Index[1] == *(cn+1)))
 197   3            {
 198   4              for (j=0; j<32; j++) //写一个字
 199   4              {   
 200   5                if (j == 16)   //由于16X16用到两个Y坐标，当大于等于16时，切换坐标
 201   5                {
 202   6                  //--设置Y坐标--//
 203   6                    LcdSt7565_WriteCmd(y + 1);
 204   6            
 205   6                  //--设置X坐标--//
 206   6                  LcdSt7565_WriteCmd(0x10 + x1);   //高4位
 207   6                  LcdSt7565_WriteCmd(0x04 + x2);  //低4位
 208   6                }
 209   5                LcdSt7565_WriteData(CN16CHAR[wordNum].Msk[j]);
 210   5              }
 211   4              x += 16;
 212   4            }//if查到字结束   
 213   3          } //for查字结束 
 214   2          cn += 2;
 215   2        } //while结束
 216   1        return 1;
 217   1      }
 218          
 219          
 220          
 221          
 222          
 223          uchar Lcd12864_Write8CnCHAR(uchar x, uchar y, uchar *cn)
 224          {
 225   1      //    uchar *cn;
 226   1        uchar j, x1, x2, wordNum;
 227   1      //  *cn = "8";
 228   1        //--Y的坐标只能从0到7，大于则直接返回--//
 229   1        if(y > 7)
 230   1        {
 231   2          return 0;
 232   2        }
 233   1      
 234   1        //--X的坐标只能从0到128，大于则直接返回--//
 235   1        if(x > 128)
 236   1        {
 237   2          return 0;
 238   2        }
 239   1        y += 0xB0;     //求取Y坐标的值
 240   1        //--设置Y坐标--//
C51 COMPILER V9.54   ST7565                                                                12/09/2024 17:21:32 PAGE 5   

 241   1        LcdSt7565_WriteCmd(y);
 242   1        while ( *cn != '\0')   //在C语言中字符串结束以‘\0’结尾
 243   1        { 
 244   2        
 245   2          //--设置Y坐标--//
 246   2          LcdSt7565_WriteCmd(y);
 247   2      
 248   2          x1 = x/0x10;   //由于X坐标要两句命令，分高低4位，所以这里先取出高4位
 249   2          x2 = x%0x10;          //去低四位
 250   2          //--设置X坐标--//
 251   2          LcdSt7565_WriteCmd(0x10 + x1);   //高4位
 252   2          LcdSt7565_WriteCmd(0x04 + x2);  //低4位
 253   2      
 254   2          for (wordNum=0; wordNum< (sizeof(CN8CHAR)/sizeof(struct Cn8CharTypeDef)); wordNum++)
 255   2          {
 256   3              //--查询要写的字在字库中的位置--//
 257   3            if ((CN8CHAR[wordNum].Index == *cn))
 258   3            {
 259   4              for (j=0; j<16; j++) //写一个字
 260   4              {   
 261   5                if (j == 8)  //由于16X16用到两个Y坐标，当大于等于16时，切换坐标
 262   5                {
 263   6                  //--设置Y坐标--//
 264   6                    LcdSt7565_WriteCmd(y + 1);
 265   6                  //--设置X坐标--//
 266   6                  LcdSt7565_WriteCmd(0x10 + x1);   //高4位
 267   6                  LcdSt7565_WriteCmd(0x04 + x2);  //低4位
 268   6                }
 269   5                LcdSt7565_WriteData(CN8CHAR[wordNum].Msk[j]);
 270   5              }
 271   4              x += 8;
 272   4            }//if查到字结束   
 273   3          } //for查字结束 
 274   2          cn += 1;
 275   2        } //while结束
 276   1        return 1;
 277   1      }
 278          
 279          
 280          
 281          #endif
 282          
 283          void test_LCD()
 284          {
 285   1        unsigned char i,s[5];
 286   1        i= sizeof(CN8CHAR)/ sizeof(struct Cn8CharTypeDef);
 287   1        s[0]=i%10 + '0';
 288   1        s[1]=i/10 + '0';
 289   1        s[2] ='\0';
 290   1        Lcd12864_Init();
 291   1        
 292   1        Lcd12864_Write16CnCHAR(40,0,"计率频");
 293   1        Lcd12864_Write8CnCHAR(0,2,s);
 294   1        
 295   1        Lcd12864_Write8CnCHAR(0,6,"5432109876543210");
 296   1        while(1);
 297   1      }
 298          
 299          


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.54   ST7565                                                                12/09/2024 17:21:32 PAGE 6   

   CODE SIZE        =    641    ----
   CONSTANT SIZE    =    347    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      13
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
